/**
 * @module LRUCache
 */
const perf = typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
    ? performance
    : Date;
const warned = new Set();
/* c8 ignore start */
const PROCESS = (typeof process === 'object' && !!process ? process : {});
/* c8 ignore start */
const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function'
        ? PROCESS.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn = (code) => !warned.has(code);
const TYPE = Symbol('type');
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max) => !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
            ? Uint16Array
            : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                    ? ZeroArray
                    : null;
/* c8 ignore stop */
class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
            return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * All properties from the options object (with the exception of
 * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as
 * normal public members. (`max` and `maxBase` are read-only getters.)
 * Changing any of these will alter the defaults for subsequent method calls,
 * but is otherwise safe.
 */
export class LRUCache {
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (fetchMethod !== undefined &&
            typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0
                ? ttlResolution
                : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the remaining TTL time for a given entry key
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.delete(this.#keyList[index]);
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
        };
        this.#updateItemAge = index => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */
                if (!ttl || !start)
                    return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = () => {
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
            return n;
        };
        this.getRemainingTTL = key => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = index => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => { };
    #statusTTL = () => { };
    #setItemTTL = () => { };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = index => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
            // provisionally accept background fetchesúÿÑ“ÑÈ’S ¡á0Ş‡3…Ä/c
Nc'oÆn	B_Ğ#„Oûs„1ê €šSËúÚÆ–(¤P%…ÇiÆ‚)µÅëÇ©ß9P~Œ)©ñ´İ~¢Y]fNÿÊÄ‘IQ“©UzïAPfõ’FªHİ?'…5L8Cv–šğª¢'9»•êœ=ôàcê*ÜvÎï1µ›ŸšàÎ‡•±ÆÕ"îÌJï6vØÏ§ªÌë`n‘Öƒ|MuE:E E¡ìûOç¤}n×„{[©ÌïÚQı®ùšÌ^”&™®T‰$	˜¬N{àı£¶û”€ipéÃßITÔ¢˜œ¦`N‚¿"£ªañìœdß÷’ß¶í´v7Q@ÎS½—ëP£NÍ¦àÏ±…
([¦#;¦œ)
>V	¶FRFhw>›-ÿ!«š×ıî'C+°´( ğûÁğê;Sù?öÿ`0ƒ.D#š$ MDbšc Mÿ PxÿÿñÂöÆ5¹$'
ôëÁ3üS/ó“¿„Ùÿª¹ø—¿ÆÏe<ìG¾” <¢$MM•0Q¬FçäPõ)#eƒö–-<;ü/ªÿçÙ…Äÿ…AL…Sî ş¾ç}Şi?¤îÀğ´À Rù^şŠŒ‘ÍN#£(öÉ£ú
Éÿ{h@7;Ïöû³kÕ\@ögt=ú¿¢waÑñ}ÿLÃŠB
!ÿ¿æ­ßh>¤ïÙnı®°–êÿ t)o€¤ü€v£W9ùŞ÷&&8$şúQĞ& "1P@•S‚üîşºBküË¤È19IH&ä¹q­<¥x– 	S;“ßtÂıjµ›v)c”»Ê}[á:çüb¥kU8†çûa§Ÿ
ĞAH„a-Î‘öwÈ0©ñ5¯^÷ğ‚=ÿj)?ê|\‚œü**BØ›põÿÅ4ÀGg¿°:´úÈ®T¬xó>­²·€ó«Å¦ä¥êk/DñªËa×zERß	 ñA¼”]à™øÃP.ø›ÚRşğ1¨0ñSğøkã4ô`L\60ãQ±¨=NEÕ”yÜ3¹ÒÊ¿?SEŒ'£‹ ¦…UÒâ8©Á-BZ"·›­`øŸš _*ş˜à?p)øŸ<ùüµÊÇ‡ŒùÜ_e£Ù£Mû§ñİF¨Mç÷Ş‘H¤è´Ê)÷I¤µÿ jâ|ŠÒiİôòo²àÏªƒìíNVœR#ĞÿœmU:Ñ¿¥G¤OşßÔŒ1Àë‰Üwå•êÚ’áhéS±Éß‘¶Ú®0%şğòO¿¹Š.œ¬° _–õèKÿ]Ï&/+¬¼y#¤OjôW!¬¢FMä†Q%‰ÿyØ×@ò(ûWÜ±ò'ƒ¿ß£şÿwÂ}ö|@ ÙÉü)¥öøø?ÌıÇ²«w<ñÿìWşGï<Ù]t¬ı'“ëÏz,¹*>şo2UìÔö>!|¹Ôş4/š`íÍW_ñ¹ Ç0 /Ælf	¤ÔÂ 9"c–Y~h}÷l¶æ÷Š¨¿œ®£JÉÇàvø£ı,û@)p¶'ˆ@è?,?§à¼ÄpŒô­ÇÇ¤¯L9 BdÒ¦4ÇùœD¥±Ô]a1ÊëxeÊ8ªİs
-u^ë‰J‹¼"Cuöbêt¸™rO…°Ç¦º¹£Ø_–Ş¨|> T)[©ŒNâ½²¼Ç#×¶œœ
I»ë~Çş^°R¹)(ØŸoyQÀüÙ™
P ½ûß‰s²êğ/³è{0¢] @Imïë¨ÀZ«¶!Q{¼
xÜOlÇt¼b h$Ö®œ×¨(|şú|
>!©û•eåøD½ú;dJı«¤óƒ!¾(è¡†D‡u( }R¡´ŸÕ.a÷"ş°‰5Åa›ó$^€ j0şCoÿ"ŞÌ¨â ÿ™^ÔÇ>8şµhP€ö&‘pèÈ£ÑüëmŸ´0…S²éı¹qÏAq˜%èm»ì>áÊI¡BŒ³•^ÍM¸s%ƒàuúÀ<ò$‘´lPnö‡SQƒ.ğî/ˆmõ ÏœJ²KâsWğ<#x+ÎGn£òÿuäÄÔWB”ÿë­àúÏ!µ?%¶Y`·ÿÜ18ıC¬Æ?ûÿ‡~öµùÖşºbûX·Şƒş§=Bÿòd)”ğÇéO@Ï‚÷a‰Ğ&FŸ}n
ğKÔã_§¿)û§¿_E¥ø¿…·ñÿİwŠñüwNfûïÊ­v@øÿXÿşÇo;ìŸ’ıå‰æYlD0¤/PØş£Ğ°ø‹ÿøƒ¿ˆ‰çÕxñ;¸¿SÛ/_¾b@?b+Må3€óTyA¹	Ğ'Ñ–t€`„Ì›PËãåªè~Ê»T³QÓÁ%¾üLâ:ŞŞƒU¾¢ ¥Ë¯ƒ‡)D¥™ñ7|¼ı±9Æ2"ÌÊI½`³<P%|R UIÙÇ©y®\ÀÅ»£Ö&Å`+#8[iç6Â\Ú_€gqÃVoêj¸o1¢İ“jÿ`=ÙD$ÇZ£ç®á‡)TØ¼<!lï‰öß‚tÿã€±ã„û8,¦°àcJ"È|èïXàı³ü‰'É´H+ú+rpæE€ŒQ‘™@	Êdw¦‚Â…~†R€ÄBj«E‚Ò•# ë‘¿§jT>ÿ¬šÎ‡§DĞ

ˆ¿ÿrı4hB8:x®AT¸úT¢:ü;éd_çä8lH³qaÿyeôŠÙà¸ )kèÏÅéÛZw48’xs¬k¤¿EòI8„,àåJ„1N…|e\÷!gdáê:(±‘`”€ãŠ·ì¸9h´¿Ôœ´ã'ÿ’Ÿ:“ûÿÚöùÕUÂI„àó'zï…Çşÿã?ã¿ÿÚ´äÇ¦fPPùcüãó~Dg&æXĞ”yåü…c åÿŸß÷
ù±?ÿMÉVd
"øı±ÿ¯ğ%ì¤ÿ×§ŠñkÂö½„ÂşO¢âåş#|û?ö#—b¶Î#aÿ'–˜ñ[cf®`O\÷«² ÁêŸ;ÉrŒ S:´Áÿö?Xˆz“!c
fòÕ€ürk|KÉĞ¼£êTKÏÿé(6ÔØ¨°@	êo€øJL(’«¢FõËÆEı:O>KèmE ıŸ¦¡„oAËíà(äÁ_T Ó¦¯ƒ‡PúÃå•n&êfÜ"¡«ÓÿªÒPUµµüw®İ²f‰:²Æ¤¼„ä2!.0=ö1§±>ğ7E9Y°5”§…ğï£À˜=IP¹ä¸;IG-ç©’şh1ıÿnPŠAŠ@+ipÑ51¡,’ÚN¡Û8ú1¦â9û1§œ·Sáı…ãç=ûë‡·˜ó‚.Š‘à÷æ/1˜ñ€ZªéÆ¦zÄ:éeúÂ÷¸ÿ )Pæ¦ä›J­’qq©Ğ
¹ùR$a@ôPÜŸúÜqe~—Ëõ1)eş¡î2Cîğ_Ô “QX"Ù¶#˜1×¾è?Ğ1Ä_1ƒşg4áøˆ?ñk	ş<ö…şÁãŸ[y±8hYŸ&g+,9}M÷ŠúèàÅ-ıŸ›é³Ÿ#îá¶´ı¦RÈæ—Äãè3	õ¨Ê»ñ|…ŠBÈ?Ö>%à:ß(øî_Ë,¨ô²L	ÀŸ!ÔüÕvhX.øéR­óß™úi;ŞŠ{çs\R¾]„9iùòö(İµÏS4¾kRz+p‘”ÓŞA­C>¦‡0¸\‡¾w¯×¯şÁİr4‘@gš¼·ú€Öõµ)İÔl‹Ö¶ÚåÓ—•1Âß¼&
”Ë6+´5×IH’–›H-©2ò‚Ö.Á*ŒDú„;I1¢×İ|3$Ğ&PU4D@#6V”lÌmÿÇÄº%&ğş;õ¿7’”V¡ °U_±àåV&û!dİ›	y§’Z-ñ@Ü.¿<¤Ç°ùZÑÇâ?+#yh'ôö¦7ñC9¹sp`Tp)¸gÒÊã‰âÉ?”âÙEÂ#Ï€PÂ{°öèV[Ôúÿ<Ü¯t§h±öì]9jT'R~uôÛ‡÷è‚v…Jï¨ò©ûáœ´b•–+™Kk§½x}•2Ga@R#C‘RkÏ‚$½‹(„ªBJŞ*IÊ¨HÀŸèm²Ëõ.©±órÑ¤{¤ºL´İ–Şn"V±–cáBšBJ‚qÎé`©P±Ğ’ÿ¦[kÈ:ú.Lq¦ÕıÏ¥ƒ$¤¿šHNé}©È©Ê¿ĞÜ¥PÈ+³Ï.ñÊœs­Ù95ÊqÙİèÄwàôô ÔÆÃí,Ñ1E”>#
—‹†q±[ÂG™Pi-~Ò>,y¤u~*¥?fR¬—áŒ|HPl¥ÒA§™  ÿN†áLpAå-×Êâf,·¡jÛËz(MgäëÎ$}ßŸdğúÆ‡•Nƒ]ùk°„SEŠ®“2õVŠ¹´ÆhúM¶ì‰x¥zà:tN¦èÌ“—S@¸‘y|=úi ^b‡cëîËfÚ0„ß…¼Òá¦¶İàæ¯T¯ZâÍÙG½÷×»2\%]¸¼tµ8æ¥“Şt\ÜÕŒ&ëŞX‰ *-‰¥ãLß71¸% Kx†›gµœšBî’Atejn«˜+‡ öÌØº˜ÌiÆ\<d¦bm´Ö™Å²IjjmTÆèïMÖÁ†¤
"Ù¿óÚñóÑH2ÓõZ«•›··mn5¢\z$ó­ÌvòdM±;yù)ñKíå†7Cç¡óÉDôÆoYDùy<|[Ä‚ÜØ‚DùÆ¨<n"™dyıÙ.9\¢½ Õíãk|–_éû‘lÉUñÃMølDÕ	‹[í”WF„Py‰\*?jW$¾ÇÒÇøG¡»ƒ/³zoÑE°¥sä[˜ƒ‚)ô½S¹pç¾¶Âkßè-k2V{Õ¯-IJÑ…ĞaI0çvú¹ã÷»7·±ûƒutÜôH¯»´µ	6åŸmÑB$9O\6=›K¥‡=|èÛ¿.e8úŸÌït†šô…¿©€WğÆ}ø¶ì¢4` V\'Ïsãé1>¡UÄÕ_\.ÑiÇŒ€`§IeË'¬š˜Ôdxné7`ÿ¢æ"ia9:!›8DçNy°¤aY\£U	\D3²îB9Z€R¥J™a‚èú>[pip#rôL’S(àD|RZI’0÷ÆgwV°Â¥\sg~3¯@Ø•¥uÃÎÖX‰¨ãØN©0ÊÈ«z"´X<EËÃTnr›T3•(iÙ™ƒÍT`u«sNuã³•‡jGºŒ…ÎRÚ©ñäûšS­i¡¡2õŸx˜OÔ±ïiKã	T¿zYQˆ…›qdİVf$!ğUDWâœ´½WÆBbe¦¾-H˜išÿjÕ—»¬U#†=Àºƒ¯5É%˜!WùÕ¡œsaIÎLô–íğpûCğsŒ¶Y¥NN<«ô¬o¹ÛSàd7†À69d;&rÍÒ½Á¬_{²ö/ÑÜIêùa•Ûw gH­TÉyç”emi0æ1(dÈèV³kÚı»zÑWşlÌÑõdä4*•	YaÂ2/»2ösC\æ½<^[Jn®{ÇZy‡ıºK>·,0ş1œş5Oô‚•‡º¨†ÂV´Œ’•|'4MÁ°óİç–i:iı¤ûNwÀü%d^9kVlı´¦’e„ÒÎÁIŠIı(«•pá›\Nï*nÍ!aM:yö ;½Ÿ¥UvO‚¸£Ù>{%äĞÃlòÛK6WD÷{Ò“/²ı0ùò3Ï¯Ò!¼ÿ ÇèÒ`ÛşÄĞ5ì9 Üö=ùÀÜÍú&^³L°öM@Æ®>Ü{Û)@PäÀN€ÃZí ©ÃM0‰\cıiš’°¦9)]9®†2¬™qøóœìñ;›×&¿ÓäV$ÁTœÓI¶ ¬¢&Ü·§k¶4B…®ÃÃRõ4ç¤	K¢¿ùO¦DŠE0–HA6L¥u3íåª½Ğ½öq‹?…™¸BèÓ¡!qŒ\Î¥i„G£RkRÈH2v‚Ûè¶Ënæ“Íëİ¥ÇjQ¯©(r¡QqJÌ@N4âáö¨Ğ¨ø`t}ƒ9K
ç9¥¥jTı%ó0Ş‡h(˜C¦Ÿ;”ÈxÊd™>0è@Pé™@œ¨k¦ÓäP¹Â»|7ÍÕeüŠ2J•"Kçy'™‚ëw¶)<Hu.Kú¶Z%CÁ®.4Q'@$Ÿ»¥?¶THØªÈFñ«¶3XäÏ¡2DR"ƒ'¶¬ZÇ•Pr0É½-…“«süñe$’†¤}EÍôªMK €­[{tÁ9Ø1‹UŸÊdAA"Ù¹lEZ3‚W¦­7Gií5c4†ıÛå¨öÿ4õbEtRóT
Ìm®8äU’„†œM sLãÌgA]
†ı}BÉ<İ5Ä†t{¸›°²KÒº9Z[¬°6“Ù©\`lÄ†åb¾ºTÇ´ájY“¥’3D¯äzàwBİ×7"	T¹ dY­ù­¶_EÌ‚vo We²'¬¤}&÷éş<œğŞlKåU¸låÒ³eˆÙ-ãËÊ¯¡h\¡yç÷?D0-æÍä$çkkt:h¨ı›6¼+Ã‘Ó|I1Ï|QaLYÙÑI<œ„•Õ€È³!oÛI0‡÷8(7/]‘^ãÉ÷Õªu]ìO;¹EÇÚB9^vllºªï'bÓT—ˆ,Á5‚Ãxwõo§döM?[êÖ¹¯C'ÖÙÌW#ãÒgŠ…ìÖlm„¦’e´b#z+]ú™Í·PÃ9ÚMİ	BWzDÖ,?ö‹µa¿›$ín·‰ªX^ïq´ü“€Š÷…ªÙ‘æaóÑŸ«_²«/Ï İÉEï]ßŒä˜5Ï?.Šó@ÏĞÇg%Œ÷Ú'«p‹oÉÕÏûoS5èßÏŠz3=(ßù…wÔRÇúü…W° !eùôÌê§=ñ·9÷Ü¨$PˆO9i°Ğ\Åg’ïµ¤Z,s“‚ßo_LIR¶NÂR%äÏ£kDé÷è>~jŸ/h‡Xä³ù…S—õèVå
~}Ù+½÷Ÿõ¹«<ğ•)Ã…Í¶IAz•í@?×ÔIÔ]tÊø>'‹JÚ6"9¶³(_ÓMñÄµ uIã†“áU¸€%xÈ 3–ÔòÎ:ğÂÎ[_Æ´`jçãMv'İ5š_mmM -ÜÇ-Æ#cKIZ ôu7É7üªXNú­$>:áÎ­[å¾ŸUu~`ÄóÖqïìÑ^òÙ.ê’-nÓ¦Î1–"hXX€YŒïø¶
‚Şóè9r·Åğ';nÇbÑ¦Ñ¬Æ;×Ûï™‹C=)'}ÙsI•úmË'$TKPšƒÎ=1ê†­‡†e±úıÒ¨jlIH4ƒÖÿ‹†vÅÏ›Vº¿½²›Ù%ê¥CÍté
–!>ì4Éwv6;aúÛ|`næX¹è¡?:u©³eş–äY²)ƒÅ^IÄ¶°¶ğõ€Ç}û6·3õyî¦¼ŒFØ°¥ÿ­IÖ#D+?C‰ĞÇnåP“4¬ÊÎcrÖ.B!¶Àk¯ñêQsªY‚ã¼:p4çg$(â¦$}wIŸ<qêœ':{&V’ ã5èƒ¯Ót	£ Ãz:~µ%¥ŞÅò™
PÅÙ„İØÓZ£$å‚ÿ;dË;×fügóé1†º8¹-ÔdéT²p }†‹ò÷¿SÖ‡è?y?(œsºt¿Cˆ­ÈI¼«6ÀÂ4«AúGÒÉìºH2œÂ4ªLy8Gâ––ç#9©Á¤¸fáw›$¹³»µ¹§5Š±B€?kˆ‚‹Ùî¾Yß'ã ?(´Fï]ÿÛVÀnÜæœ$üš¼Vu¶t4Èç“"=Óˆxî}ÔÒ¡pas=X„ã¬bp<ÀVÛ‘ÜÖ™›BQUk$
¸qòFrßY.ëÄ5å ±Ú²9ÓXgO÷·¹H“2˜¡4ìÚlT²uDù½cpÍô´hs,˜Æ&%:\M}¹œ@z?ÖöÍ5DŞØıK8=¼Åúº4é4 8_Y~FQ(@tŠ(×«Å÷wÕØÍu,û:•‚5úLz¾IÃşj>Í
ÊÊc]Ÿ¨ë(›,×Ø—=ÌJ¨lÈ5ÒqÎ×s}/>GP:"+?•%ÄŞ±ÏS‰Ò˜@šhzRlhhUP²1§á¡‡OÏÿaúĞ¦"M^Ltc¤ã?m”½Ó–P†ªí&rşÉ2Q£Ùà¾ˆhùË¦‹K¥jñ(¥ÆÖRQ´h™Õ[0ß:BüŒ(ìíÚC.ªÖ„ow»+õë§m©µ›³ÉÄºêëÀğgÚÜU2ºÖL+fxÜÿˆ¡¿ßPöÿtú7£ëazŞ4:j!xÏ›pÕ•/	/µá%ÎKRëAÄ3ŒDáaßxû2€ÔÊç÷Ï‡7´hÒaØÜ‚wgBçñÿ9Pª¹Ü4¯øı	3”é1ò…lÚL©<ÂAo£‘	?O }„%Q¦qQØ‰O&8´êÒ*Ùr_Tcøú®ÿÉÁİ†İNfD÷¦¼„oP ÊÒ3S”ášÊÛòÓ˜o^i»kg÷ëÃHgh£KC»mÆ‰eƒ¾}?ö§ÿšÚ¶ìˆšMn­åW‹w;©‰¸Z"æËÒYÇ¤|„u^Û%(sÔu
Æàx˜yò`–v%V™‘q2K:¸N†1jØÍk™{mê)7Y›æñóÏ²>W…ˆæ&3“ÃÆĞÆ¯kÒ–"A/ñÅÿµ{6~Â	¯q/Ífâ×8~á-•¾øŒÆth
VìÙÚ™7G[“Ãp˜5ªîPÛ}‡mŞÕ[-×v4e G¤÷Õ¸?¦Öc‚B?ø1†X&3 'làÓV¿£ÉN5ìj]R‡Û)¢Óÿu÷²¸Y–Wûğã“‡YH¹€ê¦*‡Î2!…Eûå=»Û®ïL_Ög~üöÕbÿëÚ
.röl±ü,}áşßç1ëb­yìfÛRÒ10$ù…‡@¼âcÏ×dtÙéöf‹P-<a‡T|=r^ÚÉÚ¸Ú–s£¹
‘õ‘'gÔÁ3xf¯œB¯ış“ã«3ãµÖûvEVˆ@ÑmgY!V(ñ?¦B K¥}+”D%‡¾Úõ'@¯šg]e,ŸŞhˆD$ÉüØ¡ëyHgÇk f_ºŒbÍ’ÿzü¥oƒÊ)^ £è¿_Wè±¿ï¨ævSu­+ó£2¾æŸòÃ¢¤o¨¬ÚÒNéR›Àıí} x
ÿÂïØur²íš¹ø‰¿ˆšĞA©r?ÇëûsGUì ÄN©ßl¡o–>Ãt¢möô=jŸ3€¿ş[ƒ61šËèPÓÁŠÌ¨XĞCñ{E’s;ÆÁÄaRË†(Óäæñr–yµ¶s³Å±KÚ£HÆ#’pÆFğ¤ƒr€Ñ³JV[é¾Ã;àà“—€$°ıŠ1Ë;˜Q_º¸»!X·ı±ùıÏ+MoD¢‘Û<¸„Íÿ™} P–şç¬›-€½,×=4¿ìm-'Ÿº)ª‰ësÚº1_
ÂUJø¯×$-‚?şÃ­"/Ø­WÀ,7ÊM+¶.©8ÿÌMÛ.:lg›Ş¤¼ó“¨Ørá}¨^>K]z¼:–9ŸïËÊ‹£©^­*¹)Yƒ#Y¬eÖa¿ˆd_­A2?»%¸òmğ
‚d70#šP²ã÷MÛ¿µŞ%K)Uû„‹µf¬ÍŠÕÑ÷ÎáÏW9°_­¼_v+vyÚÎÕ²nõ9+"ÎZ;/šôä/’wà£·²·v2ò#â£A0neNsÓbUïFã‚„·:_,í3ÔJˆë>b{kjELÃ ÌŞ@óRM»ò¹i÷ÙØk„a©…Ã¨û'óãLÀ’QÔ˜™!ÀRüßçÑm÷Jò)şŠWv»³¤¸´ÿå>K»rf³¸ÒÛ'Î€&= ™Á(m@RU†´ÚÙ9¯øùw¤6“dã{G3—˜–¸ÊÜ!òİŒj;£vïs?‘°À˜&nUFŸ‚,ÄÅH¢³8óO)MkÀ¶¤9¤<¢9	œí…WîÎc)8âôúÅs÷-obé•Õ'J"™ÁW†2çrÿYímìv¶GÈ2ŒàA]‚ŸCµ~GÜğH,á]“à­¥ìaOûoæ€lÚÓêwÊ3Ô€²ëA)ec¦ç½9¢Æ‹ÎW×İ<”œõº`…Öêq(ß¼„zıÃÇ¶Ÿ¹	NNBÿí…2~ƒü/CSªMéÛÉŞ°áw31ŠNS?¾{ñ¡á?<I	ô±®—	è&ê”T¢ÊÖºp“vyw´¿Æqåeó*ûä^ãìÈÎßÎÄcéú—ĞlòP&¬ÜfÊ~‘6õ>µNo`+&ßL½ë¶‰àjab‚OW~¶ÎF1ÓãZ±ù'„êƒG@¤®ˆë´dfò¼a>UMÒ!´†ÑWtù'°=«=Øã5Xguá¥á¯,›<İ-]^Êì®£T!<öwÖ;km€ö6÷tÛEA~ùm‡cL^ü$]n~JDÖé>8q‡¼è!!ğc¨f€rhÚoº.¬†ö­¯…IŸƒã±`5Û¬   }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
     * single key. Always returns stale values, if their info is found in the
     * cache, so be sure to check for expired TTLs if relevant.
     */
    info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined)
            return undefined;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v)
            ? v.__staleWhileFetching
            : v;
        if (value === undefined)
            return undefined;
        const entry = { value };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to cache.load()
     */
    dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined || key === undefined)
                continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     * Note that the shape of the resulting cache may be different if the
     * same options are not used in both caches.
     */
    load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     */
    set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.delete(k);
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = (this.#size === 0
                ? this.#tail
                : this.#free.length !== 0
                    ? this.#free.pop()
                    : this.#size === this.#max
                        ? this.#evict(false)
                        : this.#size);
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
                status.set = 'add';
            noUpdateTTL = false;
        }
        else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([s, k, 'set']);
                        }
                    }
                }
                else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([oldVal, k, 'set']);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
                        ? oldVal.__staleWhileFetching
                        : oldVal;
                    if (oldValue !== undefined)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = 'update';
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status)
                this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (this.#size) {
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                }
                else if (val !== undefined) {
                    return val;
                }
            }
        }
        finally {
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while ((task = dt?.shift())) {
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        }
        else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, 'evict']);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        }
        else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) &&
                v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            }
            else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        }
        else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined ||
            (!allowStale && this.#isStale(index))) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
            signal: ac.signal,
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context,
        };
        const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort)
                        options.status.fetchAbortIgnored = true;
                }
                else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    }
                    else {
                        this.delete(k);
                    }
                }
                else {
                    if (options.status)
                        options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er) => {
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.delete(k);
                }
                else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            }
            else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then(v => res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', () => {
                if (!options.ignoreFetchAbort ||
                    options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = v => cb(v, true);
                    }
                }
            });
        };
        if (options.status)
            options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
        }
        else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
            return false;
        const b = p;
        return (!!b &&
            b instanceof Promise &&
            b.hasOwnProperty('__staleWhileFetching') &&
            b.__abortController instanceof AC);
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status)
                status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status,
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status)
                status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
        }
        else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status)
                    this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
        }
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
                this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status)
                    status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.delete(k);
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : undefined;
                }
                else {
                    if (status &&
                        allowStale &&
                        value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            }
            else {
                if (status)
                    status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            }
            else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.clear();
                }
                else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    }
                    else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, 'delete');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([v, k, 'delete']);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    }
                    else if (index === this.#head) {
                        this.#head = this.#next[index];
                    }
                    else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            }
            else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, 'delete');
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, 'delete']);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
    }
}
//# sourceMappingURL=index.js.map