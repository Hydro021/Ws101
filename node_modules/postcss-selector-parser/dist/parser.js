"use strict";

exports.__esModule = true;
exports["default"] = void 0;
var _root = _interopRequireDefault(require("./selectors/root"));
var _selector = _interopRequireDefault(require("./selectors/selector"));
var _className = _interopRequireDefault(require("./selectors/className"));
var _comment = _interopRequireDefault(require("./selectors/comment"));
var _id = _interopRequireDefault(require("./selectors/id"));
var _tag = _interopRequireDefault(require("./selectors/tag"));
var _string = _interopRequireDefault(require("./selectors/string"));
var _pseudo = _interopRequireDefault(require("./selectors/pseudo"));
var _attribute = _interopRequireWildcard(require("./selectors/attribute"));
var _universal = _interopRequireDefault(require("./selectors/universal"));
var _combinator = _interopRequireDefault(require("./selectors/combinator"));
var _nesting = _interopRequireDefault(require("./selectors/nesting"));
var _sortAscending = _interopRequireDefault(require("./sortAscending"));
var _tokenize = _interopRequireWildcard(require("./tokenize"));
var tokens = _interopRequireWildcard(require("./tokenTypes"));
var types = _interopRequireWildcard(require("./selectors/types"));
var _util = require("./util");
var _WHITESPACE_TOKENS, _Object$assign;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
function tokenStart(token) {
  return {
    line: token[_tokenize.FIELDS.START_LINE],
    column: token[_tokenize.FIELDS.START_COL]
  };
}
function tokenEnd(token) {
  return {
    line: token[_tokenize.FIELDS.END_LINE],
    column: token[_tokenize.FIELDS.END_COL]
  };
}
function getSource(startLine, startColumn, endLine, endColumn) {
  return {
    start: {
      line: startLine,
      column: startColumn
    },
    end: {
      line: endLine,
      column: endColumn
    }
  };
}
function getTokenSource(token) {
  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
}
function getTokenSourceSpan(startToken, endToken) {
  if (!startToken) {
    return undefined;
  }
  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
}
function unescapeProp(node, prop) {
  var value = node[prop];
  if (typeof value !== "string") {
    return;
  }
  if (value.indexOf("\\") !== -1) {
    (0, _util.ensureObject)(node, 'raws');
    node[prop] = (0, _util.unesc)(value);
    if (node.raws[prop] === undefined) {
      node.raws[prop] = value;
    }
  }
  return node;
}
function indexesOf(array, item) {
  var i = -1;
  var indexes = [];
  while ((i = array.indexOf(item, i + 1)) !== -1) {
    indexes.push(i);
  }
  return indexes;
}
function uniqs() {
  var list = Array.prototype.concat.apply([], arguments);
  return list.filter(function (item, i) {
    return i === list.indexOf(item);
  });
}
var Parser = /*#__PURE__*/function () {
  function Parser(rule, options) {
    if (options === void 0) {
      options = {};
    }
    this.rule = rule;
    this.options = Object.assign({
      lossy: false,
      safe: false
    }, options);
    this.position = 0;
    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;
    this.tokens = (0, _tokenize["default"])({
      css: this.css,
      error: this._errorGenerator(),
      safe: this.options.safe
    });
    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
    this.root = new _root["default"]({
      source: rootSource
    });
    this.root.errorGenerator = this._errorGenerator();
    var selector = new _selector["default"]({
      source: {
        start: {
          line: 1,
          column: 1
        }
      }
    });
    this.root.append(selector);
    this.current = selector;
    this.loop();
  }
  var _proto = Parser.prototype;
  _proto._errorGenerator = function _errorGenerator() {
    var _this = this;
    return function (message, errorOptions) {
      if (typeof _this.rule === 'string') {
        return new Error(message);
      }
      return _this.rule.error(message, errorOptions);
    };
  };
  _proto.attribute = function attribute() {
    var attr = [];
    var startingToken = this.currToken;
    this.position++;
    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
      attr.push(this.currToken);
      this.position++;
    }
    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
    }
    var len = attr.length;
    var node = {
      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
    };
    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);
    }
    var pos = 0;
    var spaceBefore = '';
    var commentBefore = '';
    var lastAdded = null;
    var spaceAfterMeaningfulToken = false;
    while (pos < len) {
      var token = attr[pos];
      var content = this.content(token);
      var next = attr[pos + 1];
      switch (token[_tokenize.FIELDS.TYPE]) {
        case tokens.space:
          // if (
          //     len === 1 ||
          //     pos === 0 && this.content(next) === '|'
          // ) {
          //     return this.expected('attribute', token[TOKEN.START_POS], content);
          // }
          spaceAfterMeaningfulToken = true;
          if (this.options.lossy) {
            break;
          }
          if (lastAdded) {
            (0, _util.ensureObject)(node, 'spaces', lastAdded);
            var prevContent = node.spaces[lastAdded].after || '';
            node.spaces[lastAdded].after = prevContent + content;
            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;
            if (existingComment) {
              node.raws.spaces[lastAdded].after = existingComment + content;
            }
          } else {
            spaceBefore = spaceBefore + content;
            commentBefore = commentBefore + content;
          }
          break;
        case tokens.asterisk:
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
            if (spaceBefore) {
              (0, _util.ensureObject)(node, 'spaces', 'attribute');
              node.spaces.attribute.before = spaceBefore;
              spaceBefore = '';
            }
            if (commentBefore) {
              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
              node.raws.spaces.attribute.before = spaceBefore;
              commentBefore = '';
            }
            node.namespace = (node.namespace || "") + content;
            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;
            if (rawValue) {
              node.raws.namespace += content;
            }
            lastAdded = 'namespace';
          }
          spaceAfterMeaningfulToken = false;
          break;
        case tokens.dollar:
          if (lastAdded === "value") {
            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');
            node.value += "$";
            if (oldRawValue) {
              node.raws.value = oldRawValue + "$";
            }
            break;
          }
        // Falls through
        case tokens.caret:
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }
          spaceAfterMeaningfulToken = false;
          break;
        case tokens.combinator:
          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }
          if (content !== '|') {
            spaceAfterMeaningfulToken = false;
            break;
          }
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if (!node.namespace && !node.attribute) {
            node.namespace = true;
          }
          spaceAfterMeaningfulToken = false;
          break;
        case tokens.word:
          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals &&
          // this look-ahead probably fails with comment nodes involved.
          !node.operator && !node.namespace) {
            node.namespace = content;
            lastAdded = 'namespace';
          } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
            if (spaceBefore) {
              (0, _util.ensureObject)(node, 'spaces', 'attribute');
              node.spaces.attribute.before = spaceBefore;
              spaceBefore = '';
            }
            if (commentBefore) {
              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
              node.raws.spaces.attribute.before = commentBefore;
              commentBefore = '';
            }
            node.attribute = (node.attribute || "") + content;
            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;
            if (_rawValue) {
              node.raws.attribute += content;
            }
            lastAdded = 'attribute';
          } else if (!node.value && node.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node.quoteMark)) {
            var _unescaped = (0, _util.unesc)(content);
            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';
            var oldValue = node.value || '';
            node.value = oldValue + _unescaped;
            node.quoteMark = null;
            if (_unescaped !== content || _oldRawValue) {
              (0, _util.ensureObject)(node, 'raws');
              node.raws.value = (_oldRawValue || oldValue) + content;
            }
            lastAdded = 'value';
          } else {
            var insensitive = content === 'i' || content === "I";
            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {
              node.insensitive = insensitive;
              if (!insensitive || content === "I") {
                (0, _util.ensureObject)(node, 'raws');
                node.raws.insensitiveFlag = content;
              }
              lastAdded = 'insensitive';
              if (spaceBefore) {
                (0, _util.ensureObject)(node, 'spaces', 'insensitive');
                node.spaces.insensitive.before = spaceBefore;
                spaceBefore = '';
              }
              if (commentBefore) {
                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');
                node.raws.spaces.insensitive.before = commentBefore;
                commentBefore = '';
              }
            } else if (node.value || node.value === '') {
              lastAdded = 'value';
              node.value += content;
              if (node.raws.value) {
                node.raws.value += content;
              }
            }
          }
          spaceAfterMeaningfulToken = false;
          break;
        case tokens.str:
          if (!node.attribute || !node.operator) {
            return this.error("Expected an attribute followed by an operator preceding the string.", {
              index: token[_tokenize.FIELDS.START_POS]
            });
          }
          var _unescapeValue = (0, _attribute.unescapeValue)(content),
            unescaped = _unescapeValue.unescaped,
            quoteMark = _unescapeValue.quoteMark;
          node.value = unescaped;
          node.quoteMark = quoteMark;
          lastAdded = 'value';
          (0, _util.ensureObject)(node, 'raws');
          node.raws.value = content;
          spaceAfterMeaningfulToken = false;
          break;
        case tokens.equals:
          if (!node.attribute) {
            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);
          }
          if (node.value) {
            return this.error('Unexpected "=" found; an operator was already defined.', {
              index: token[_tokenize.FIELDS.START_POS]
            });
          }
          node.operator = node.operator ? node.operator + content : content;
          lastAdded = 'operator';
          spaceAfterMeaningfulToken = false;
          break;
        case tokens.comment:
          if (lastAdded) {
            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {
              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';
              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;
              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);
              node.raws.spaces[lastAdded].after = rawLastComment + content;
            } else {
              var lastValue = node[lastAdded] || '';
              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;
              (0, _util.ensureObject)(node, 'raws');
              node.raws[lastAdded] = rawLastValue + content;
            }
          } else {
            commentBefore = commentBefore + content;
          }
          break;
        default:
          return this.error("Unexpected \"" + content + "\" found.", {
            index: token[_tokenize.FIELDS.START_POS]
          });
      }
      pos++;
    }
    unescapeProp(node, "attribute");
    unescapeProp(node, "namespace");
    this.newNode(new _attribute["default"](node));
    this.position++;
  }

  /**
   * return a node containing meaningless garbage up to (but not including) the specified token position.
   * if the token position is negative, all remaining tokens are consumed.
   *
   * This returns an array containing a single string node if all whitespace,
   * otherwise an array of comment nodes with space before and after.
   *
   * These tokens are not added to the current selector, the caller can add them or use them to amend
   * a previous node's space metadata.
   *
   * In lossy mode, this returns only comments.
   */;
  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
    if (stopPosition < 0) {
      stopPosition = this.tokens.length;
    }
    var startPosition = this.position;
    var nodes = [];
    var space = "";
    var lastComment = undefined;
    do {
      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
        if (!this.options.lossy) {
          space += this.content();
        }
      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
        var spaces = {};
        if (space) {
          spaces.before = space;
          space = "";
        }
        lastComment = new _comment["default"]({
          value: this.content(),
          source: getTokenSource(this.currToken),
          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
          spaces: spaces
        });
        nodes.push(lastComment);
      }
    } while (++this.position < stopPosition);
    if (space) {
      if (lastComment) {
        lastComment.spaces.after = space;
      } else if (!this.options.lossy) {
        var firstToken = this.tokens[startPosition];
        var lastToken = this.tokens[this.position - 1];
        nodes.push(new _string["default"]({
          value: '',
          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
          spaces: {
            before: space,
            after: ''
          }
        }));
      }
    }
    return nodes;
  }

  /**
   *
   * @param {*} nodes
   */;
  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
    var _this2 = this;
    if (requiredSpace === void 0) {
      requiredSpace = false;
    }
    var space = "";
    var rawSpace = "";
    nodes.forEach(function (n) {
      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);
      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);
      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
    });
    if (rawSpace === space) {
      rawSpace = undefined;
    }
    var result = {
      space: space,
      rawSpace: rawSpace
    };
    return result;
  };
  _proto.isNamedCombinator = function isNamedCombinator(position) {
    if (position === void 0) {
      position = this.position;
    }
    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
  };
  _proto.namedCombinator = function namedCombinator() {
    if (this.isNamedCombinator()) {
      var nameRaw = this.content(this.tokens[this.position + 1]);
      var name = (0, _util.unesc)(nameRaw).toLowerCase();
      var raws = {};
      if (name !== nameRaw) {
        raws.value = "/" + nameRaw + "/";
      }
      var node = new _combinator["default"]({
        value: "/" + name + "/",
        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
        raws: raws
      });
      this.position = this.position + 3;
      return node;
    } else {
      this.unexpected();
    }
  };
  _proto.combinator = function combinator() {
    var _this3 = this;
    if (this.content() === '|') {
      return this.namespace();
    }
    // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.
    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
      if (nodes.length > 0) {
        var last = this.current.last;
        if (last) {
          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),
            space = _this$convertWhitespa.space,
            rawSpace = _this$convertWhitespa.rawSpace;
          if (rawSpace !== undefined) {
            last.rawSpaceAfter += rawSpace;
          }
          last.spaces.after += space;
        } else {
          nodes.forEach(function (n) {
            return _this3.newNode(n);
          });
        }
      }
      return;
    }
    var firstToken = this.currToken;
    var spaceOrDescendantSelectorNodes = undefined;
    if (nextSigTokenPos > this.position) {
      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
    }
    var node;
    if (this.isNamedCombinator()) {
      node = this.namedCombinator();
    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
      node = new _combinator["default"]({
        value: this.content(),
        source: getTokenSource(this.currToken),
        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
      });
      this.position++;
    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
      // pass
    } else if (!spaceOrDescendantSelectorNodes) {
      this.unexpected();
    }
    if (node) {
      if (spaceOrDescendantSelectorNodes) {
        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),
          _space = _this$convertWhitespa2.space,
          _rawSpace = _this$convertWhitespa2.rawSpace;
        node.spaces.before = _space;
        node.rawSpaceBefore = _rawSpace;
      }
    } else {
      // descendant combinator
      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),
        _space2 = _this$convertWhitespa3.space,
        _rawSpace2 = _this$convertWhitespa3.rawSpace;
      if (!_rawSpace2) {
        _rawSpace2 = _space2;
      }
      var spaces = {};
      var raws = {
        spaces: {}
      };
      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {
        spaces.before = _space2.slice(0, _space2.length - 1);
        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {
        spaces.after = _space2.slice(1);
        raws.spaces.after = _rawSpace2.slice(1);
      } else {
        raws.value = _rawSpace2;
      }
      node = new _combinator["default"]({
        value: ' ',
        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
        spaces: spaces,
        raws: raws
      });
    }
    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
      node.spaces.after = this.optionalSpace(this.content());
      this.position++;
    }
    return this.newNode(node);
  };
  _proto.comma = function comma() {
    if (this.position === this.tokens.length - 1) {
      this.root.trailingComma = true;
      this.position++;
      return;
    }
    this.current._inferEndPosition();
    var selector = new _selector["default"]({
      source: {
        start: tokenStart(this.tokens[this.position + 1])
      }
    });
    this.current.parent.append(selector);
    this.current = selector;
    this.position++;
  };
  _proto.comment = function comment() {
    var current = this.currToken;
    this.newNode(new _comment["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };
  _proto.error = function error(message, opts) {
    throw this.root.error(message, opts);
  };
  _proto.missingBackslash = function missingBackslash() {
    return this.error('Expected a backslash preceding the semicolon.', {
      index: this.currToken[_tokenize.FIELDS.START_POS]
    });
  };
  _proto.missingParenthesis = function missingParenthesis() {
    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
  };
  _proto.missingSquareBracket = function missingSquareBracket() {
    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
  };
  _proto.unexpected = function unexpected() {
    return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
  };
  _proto.unexpectedPipe = function unexpectedPipe() {
    return this.error("Unexpected '|'.", this.currToken[_tokenize.FIELDS.START_POS]);
  };
  _proto.namespace = function namespace() {
    var before = this.prevToken && this.content(this.prevToken) || true;
    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
      this.position++;
      return this.word(before);
    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
      this.position++;
      return this.universal(before);
    }
    this.unexpectedPipe();
  };
  _proto.nesting = function nesting() {
    if (this.nextToken) {
      var nextContent = this.content(this.nextToken);
      if (nextContent === "|") {
        this.position++;
        return;
      }
    }
    var current = this.currToken;
    this.newNode(new _nesting["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };
  _proto.parentheses = function parentheses() {
    var last = this.current.last;
    var unbalanced = 1;
    this.position++;
    if (last && last.type === types.PSEUDO) {
      var selector = new _selector["default"]({
        source: {
          start: tokenStart(this.tokens[this.position - 1])
        }
      });
      var cache = this.current;
      last.append(selector);
      this.current = selector;
      while (this.position < this.tokens.length && unbalanced) {
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          unbalanced++;
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          unbalanced--;
        }
        if (unbalanced) {
          this.parse();
        } else {
          this.current.source.end = tokenEnd(this.currToken);
          this.current.parent.source.end = tokenEnd(this.currToken);
          this.position++;
        }
      }
      this.current = cache;
    } else {
      // I think this case should be an error. It's used to implement a basic parse of media queries
      // but I don't think it's a good idea.
      var parenStart = this.currToken;
      var parenValue = "(";
      var parenEnd;
      while (this.position < this.tokens.length && unbalanced) {
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          unbalanced++;
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          unbalanced--;
        }
        parenEnd = this.currToken;
        parenValue += this.parseParenthesisToken(this.currToken);
        this.position++;
      }
      if (last) {
        last.appendToPropertyAndEscape("value", parenValue, parenValue);
      } else {
        this.newNode(new _string["default"]({
          value: parenValue,
          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
        }));
      }
    }
    if (unbalanced) {
      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
    }
  };
  _proto.pseudo = function pseudo() {
    var _this4 = this;
    var pseudoStr = '';
    var startingToken = this.currToken;
    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
      pseudoStr += this.content();
      this.position++;
    }
    if (!this.currToken) {
      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
    }
    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
      this.splitWord(false, function (first, length) {
        pseudoStr += first;
        _this4.newNode(new _pseudo["default"]({
          value: pseudoStr,
          source: getTokenSourceSpan(startingToken, _this4.currToken),
          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        }));
        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          _this4.error('Misplaced parenthesis.', {
            index: _this4.nextToken[_tokenize.FIELDS.START_POS]
          });
        }
      });
    } else {
      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);
    }
  };
  _proto.space = function space() {
    var content = this.content();
    // Handle space before and after the selector
    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {
      return node.type === 'comment';
    })) {
      this.spaces = this.optionalSpace(content);
      this.position++;
    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
      this.current.last.spaces.after = this.optionalSpace(content);
      this.position++;
    } else {
      this.combinator();
    }
  };
  _proto.string = function string() {
    var current = this.currToken;
    this.newNode(new _string["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };
  _proto.universal = function universal(namespace) {
    var nextToken = this.nextToken;
    if (nextToken && this.content(nextToken) === '|') {
      this.position++;
      return this.namespace();
    }
    var current = this.currToken;
    this.newNode(new _universal["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }), namespace);
    this.position++;
  };
  _proto.splitWord = function splitWord(namespace, firstCallback) {
    var _this5 = this;
    var nextToken = this.nextToken;
    var word = this.content();
    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
      this.position++;
      var current = this.content();
      word += current;
      if (current.lastIndexOf('\\') === current.length - 1) {
        var next = this.nextToken;
        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
          word += this.requiredSpace(this.content(next));
          this.position++;
        }
      }
      nextToken = this.nextToken;
    }
    var hasClass = indexesOf(word, '.').filter(function (i) {
      // Allow escaped dot within class name
      var escapedDot = word[i - 1] === '\\';
      // Allow decimal numbers percent in @keyframes
      var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
      return !escapedDot && !isKeyframesPercent;
    });
    var hasId = indexesOf(word, '#').filter(function (i) {
      return word[i - 1] !== '\\';
    });
    // Eliminate Sass interpolations from the list of id indexes
    var interpolations = indexesOf(word, '#{');
    if (interpolations.length) {
      hasId = hasId.filter(function (hashIndex) {
        return !~interpolations.indexOåÇ4 ê  À ®c4 À <Ã §Ç4 DÃ ËÃ ÃÇ4 Ã ∫Õ ËÇ4 ¿Õ Œ  É4 Œ cŒ É4 cŒ kŒ  É4 kŒ œ 4É4 œ ªœ LÉ4 ªœ – `É4 – — pÉ4 — -— ÑÉ4 -— A— îÉ4 H— ≠” Ñ4 ¥” ò‘ $Ñ4 †‘ É’ LÑ4 å’ Ú’ »&4 ¯’ 4÷ »&4 <÷ q÷ hÑ4 x÷ v◊ ÄÑ4 |◊ ”◊ 8%4 ‡◊ 4ÿ §Ñ4 4ÿ ïÿ ¥Ñ4 ïÿ µÿ »Ñ4 ºÿ ¥Ÿ ÏÑ4 ¿Ÿ ¥⁄ Ö4 ¿⁄ Ø‰ tÖ4 ∏‰ +Â  Ü4 @Â  Ì  Ü4 –Ì Ô ƒÜ4   î˚ ÏÜ4 ú˚ Ô˛ á4  ˇ  @á4  ‰ pá4 Ï ~ dj4 Ñ ≈ –&4 Ã © òá4 ∞ û ¿á4 ∞ % ‰á4 % ∑  à4 ∑ È à4 È Ò (à4 Ò  8à4  3 Hà4 3 : `à4 : n tà4 n u åà4 ‡ ∞ ƒà4 ∏ À! ‰à4 ‘! ≈" â4 Ã" # »&4 $# w$ 8â4 Ä$ ◊$ 8%4 ‡$ % »&4 % ò& Tâ4 †& ﬁ( Ñâ4 ) <) »&4 D) ™* ¸â4 ∞* + –&4 + ª+ ËÇ4 ƒ+ *, L&4 0, µ, ,ä4 ¿, Å- Dä4 ê- . L&4 . Ä/ lä4 à/ 0 X(4 0 Õ0 îä4 ‘0 ⁄1 ∏ä4 ‡1 3 ã4 3 ˘3 ∞ã4  4 h4 ÄC4 p4 ô4 »&4 †4 95 ‰,4 @5 6 ¸-4  6 8 ‹ã4 $8 õ8 –&4 §8 9 ¯/4 9 K9 Hå4 T9 ﬂ9 ¸-4 Ë9 : `å4 ¯: ò; åå4 †; Í< ¨å4 < §= ç4 ¨= b> (4 h> Ø> <ç4 ∏> /? tç4 8? v? ƒç4 |? @ 8%4  @ ¬@ L&4 »@ ˚@ –&4 A DC é4 LC ⁄C X(4 ‡C áD †é4 êD ©E ¨é4 ∞E ¶G ‘é4 ¨G H ÄC4 H ªH dè4 ÑI +J òè4 @J xJ ê4 ÄJ ØJ –&4 ∏J K ê4 K qK (ê4 xK eL Dê4 lL M Hd4 M ÄM <4 àM õO |ê4 §O P ÄC4 P ~P ÄC4 ÑP •Q ¨ê4 ∞Q ÌR ¸ê4 ÙR S –&4  S iS –&4 pS ﬁS $ë4 ‰S -T L&4 4T _T ,ë4 hT $U `94 0U õU 8%4 §U ˜U Hë4  V •V `ë4 ¨V iW òë4 êW ˆW ∞ë4 ¸W ñX L&4 úX nZ Ãë4 tZ ﬂZ –&4 Z [ »&4 [ \ ¯ë4  \ 4\ »&4 <\ È\ í4 \ »] ¸-4 –] Ï] »&4 Ù] _a @í4 pa ob ∏í4 Äb úb ‹í4 úb Îb Ëí4 Îb ùc  ì4 ùc ±c ì4 ±c ≤c $ì4 ≤c Ãc 4ì4 Ãc ﬂc Lì4 Ëc Åd ∞ì4 àd Ûd î4 ¸d âe ,î4 êe ˛e å@4 f Äh Dî4 àh €h ∞î4 ‰h øi –î4 »i Xl Ïî4 `l wn Xï4 Än ˜n Äï4  o jo L&4 po ›o –&4 ‰o |p àï4 Ñp q ¨ï4 q Eq –&4 Pq ór ‘ï4 †r s ÄC4 s {s L&4 Ñs éu 8ñ4 îu √u »&4 ¯u ∑v hñ4 ¿v ä xñ4  ä Jì  ó4 Pì Üñ Dó4 åñ ˝ñ ∞ó4 ó 'ó »&4 0ó òó ÿó4 †ó Bô 4ò4 Hô ö hò4 ö Tõ dj4 \õ ùú êò4 §ú "ù ¯/4 (ù ı† ¥ò4 ¸† "° »&4 0° ¥° Ãò4 º° l¢ ô4 t¢ ¡£ pô4 –£ ·¶ –ô4 ¶ ]® 4ö4 d® ‘® Hö4 ‡® © hö4 © ç© |ö4 ç© é© êö4 é©  © †ö4 –© F¨ »ö4 L¨ ø≠ (õ4 –≠ Â≠ »&4 Ï≠ üÆ <õ4 ®Æ zØ 4B4 ÄØ S∞ põ4 \∞ õ∞ –&4 §∞ ?± Ù94 l± û± 8%4 §± f≤ ƒõ4 l≤ û≤ 8%4 §≤ Z≥ 8%4 `≥ —≥ ÄC4 ÿ≥ d¥ ,ú4 l¥ ÷ƒ Dú4 ‹ƒ ≈ hú4  ≈ ë≈ Ñú4 ò≈ Ê≈ †ú4 Ï≈ ∆ ºú4 0∆ E∆ »&4 L∆ F« ‘ú4 Ä« 6» ú4 <» x» 8%4 ¥» »… ù4 –… À <ù4 À öÀ Pù4 †À íÃ hù4 òÃ ÆÕ àù4 ¿Õ ÒÕ –&4 ¯Õ AŒ »&4 HŒ 5÷ ∞ù4 |÷ ªŸ ¯ù4 ‰Ÿ I€ <û4 P€ ¡‹ dû4 ﬁ Lﬁ L&4 Tﬁ 	ﬂ Ñû4 ﬂ gﬂ ‰,4 pﬂ «ﬂ ‰,4 –ﬂ ñ‡ ∞û4 ú‡ K· ÿû4 T· ´· ‰,4 ¥· ‚ ‰,4 ‚ ^‚ L&4 d‚ £‚ »&4 ¨‚ ¡‚ ü4 »‚ ˘‚ –&4  „ ≤„ ü4 ∏„ P‰ Pü4 X‰ Ø‰ <4 ∏‰ Â 8%4 Â @Í |ü4 HÍ +Î ‹ü4 4Î îÎ L&4 úÎ  Ï <†4 Ï .Ï »&4 4Ï ,Ì h†4 4Ì §Ó î†4 ¨Ó iÔ L&4 pÔ $Ò ¥†4 ,Ò ëÒ –&4 òÒ (Ú Ã†4 0Ú íÚ ¸†4 ºÚ ùÙ °4 §Ù íı D°4 òı ·ı »&4 Ëı ùˆ h°4 §ˆ Ç˜ î°4 à˜ ﬂ˜ ¨°4 Ë˜ Ö˘ ƒ°4 å˘ ∫˘ 8%4 ¿˘ ú˙ ,¢4 ∞˙ Õ˝ Ñ¢4 ‘˝ ˘˝ –&4  ˛ 9˛ –&4 @˛ t˛ ¯¢4 |˛ ˇ˛ £4 ˇ ‹ˇ 0£4 ‰ˇ ·  P£4 Ë  m –&4 t " (4 ( g –&4 p  L&4  ¨ p£4 ¥ 7 Ã£4 @ Ê ÄC4 Ï 4 8%4 < ê 8%4 ò D ‰£4 L ¢ 8%4 ® * –&4 0 ∞ @§4 ∏ „ –&4 Ï Q	  É4 X	 £	 Ä§4 ¨	 Z
 –§4 `
 7 ‰§4 @  ¸§4  Ë •4   »&4   q (•4 x À 8%4 ‘ N H•4 T ◊ L&4 ‡ ‹ h•4  M ∏•4 M É ƒ•4 É À ÿ•4 À ;  Ë•4 ;  Î  ¸•4 Î  Ú  ¶4 ¯  ß! T¶4 ∞! ’! –&4 ‹! " –&4 " f" Ñ¶4 l" G$ å¶4 P$ È$ §¶4 $ % å@4 % û% 0E4 §% ô) ¥¶4 †) Ó)  ß4 Ù) w* 8ß4 Ä*  + X(4 + A+ –&4 H+ |+ Xß4 ê+ Ê+ pß4 Ï+ ü, ,ä4 ®, Ù- úß4 ¸- ‘. »ß4 . ñ0 Ùß4 ú0 ˚1 |®4 2 «2 ÿ®4 –2 h3 ¸®4 p3 44 ©4 <4 ^4 0©4 p4 Â4 H©4 Ï4 
5 ¨©4 5 95 ƒ©4 @5 ã5 å@4 î5 ˜5 ‹©4  6 26 –&4 86 ·7 ¯©4 Ë7 J8 T™4 P8 ©; t™4 ∞; 
< ‰,4 < †> §™4 ®> ñ? ‘™4 ú? A êw4  A óA dj4 †A B Ï™4  B ¸B Hd4 C âC –&4 êC œC –&4 ÿC }D  ´4 ÑD ©D –&4 ∞D IG ´4 PG ,H Hd4 @H lH å@4 tH 1J å´4 8J K ∏´4 K DL ‘´4 LL ŸL Ù94 ‡L dP  ¨4 lP }Q ¨4 ÑQ √R ÄC4 ÃR πT 8¨4 ¿T 9U X¨4 |U ßV p¨4 ∞V "W Ñ¨4 (W ∂W §64 ºW ≠X †¨4 ¿X HY L&4 PY |Y Ã¨4 ÑY ÕY 8%4 ‘Y =[ Ë¨4 D[ \ ≠4  \ ¥\ 0≠4 º\ Í\ –&4 \ ö] Ñ≠4 †] +^ §≠4 4^ _ ƒ≠4 _ z_ L&4 Ä_ *` Ë≠4 0` ñ` ¸≠4 ú` a Æ4 a  a 8Æ4 –a ˚b L&4 c 2c LÆ4 8c ´c dÆ4 ¥c “c |Æ4 ÿc Rd îÆ4 Xd ôd å@4 †d ¨q ¨Æ4 ¥q 2r –Æ4 pr ¥s ¯Æ4 ¿s Ís å@4 s ht Ø4 pt /u 8Ø4 @u ju å@4 pu ≤u XØ4 ∏u v 8%4 v vx tØ4 Äx y ¯/4  y Qy –&4 Xy Éy ÿØ4 êy ê} ÙØ4 †} ;~ ∞4 P~ z~ å@4 Ä~ ‹ 8∞4  Ä JÄ å@4 PÄ ›Å d∞4 ‰Å ÄÇ Ñ∞4 àÇ ÎÉ ®∞4  Ñ 5Ñ ‘∞4 @Ñ tÑ 8%4 ÄÑ LÖ ∞4 TÖ ≥Ö L&4 ºÖ uÜ  ±4 |Ü câ ,±4 lâ îä H±4 dã ‘ã l±4 ‹ã Nå à±4 Tå ◊å §±4 ‡å †ç »±4 ®ç …é ¯±4  è ^ë $≤4 dë Eì P≤4 Lì ]î t≤4 dî :ñ †≤4 @ñ ßö »≤4 ∞ö õ ¯/4 0õ 
ú ¸≤4 ú Zù (≥4 `ù ⁄ù T≥4 ‡ù {≥ p≥4 ê≥ ÿ∂ ‹≥4 ‡∂ ∏π ¥4 ‡π ¡ <¥4 ¡ ò¡ 04 †¡ X√ \¥4 `√ °√ ƒ¥4 ®√ ë≈ ‰¥4 †≈ I« µ4 P« ∫« 0µ4 ¿« ÷« Lµ4 ‹« w» 8Æ4 Ä» %…  ´4 ,… ®… `µ4 ∞… °  »µ4 ®  ˛  µ4 À sÕ 4B4 |Õ úÕ ∂4 §Õ Œ 8%4 Œ NŒ (∂4 TŒ ΩŒ H∂4 ƒŒ rœ (4 Äœ ò– h∂4 †– ,— 04 4— è— Ñ∂4 ƒ— t“ ®∂4 |“ …“ ¿∂4 –“ æ” ÿ∂4 ƒ” …‘  ∑4 –‘ :÷ T∑4 @÷ t÷ 8%4 Ä÷ –÷ ¯X4 ÿ÷ ¬◊ t∑4 –◊ ¶ÿ ¨∑4 ∞ÿ UŸ ‡∑4 †Ÿ ù€ ¸∑4 ∞€ w› ,∏4 Ä› gﬁ T∏4 pﬁ Ï‡ l∏4 Ù‡ · †∏4 · Ç· ∏∏4 à· |‰ ‘∏4 Ñ‰ ΩÂ Lπ4 ƒÂ µÊ ∏π4 Ê ˜È ‘π4  Í Ï X∫4  Ï $Ì Ä∫4 0Ì †Ù Ã∫4 ®Ù –ı ‰∫4 ÿı ˆ ª4 $ˆ ﬂˆ 8%4 Ëˆ 5˜ $ª4 @˜ ∫¯ @ª4 ¿¯ w˘ pª4 Ä˘ ”˙ úª4 ‡˙ i˚ ∏ª4 p˚ §˝ ‹ª4 ¨˝ À˛ 4º4 ‡˛ € Lº4  © Äº4 ∞ ∂ ‰º4 ¿ $ ,Ω4 0 ò? æ4 †? @ §æ4 @ ˆ@ ∏æ4 ˆ@ ƒA Ãæ4 –A 2B Ùæ4 2B ∂C ø4 ∂C ¬C  ø4 ¬C ≈D 0ø4 –D K hø4 K PK úø4 PK jK ∏ø4 jK éK Ãø4 éK jO ‰ø4 jO ûQ ¿4 ûQ ≈Q $¿4 ≈Q ÕQ 8¿4 ÕQ ÈQ H¿4 ÈQ µR X¿4 ¿R S ¡4 S #S (¡4 #S ÍX <¡4 ÍX ÚX T¡4 ÚX Y d¡4 Y ´Y t¡4 ¥Y )Z ¨¡4 0Z ^[ ÿ¡4 p[ 